Index: core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/GameScene.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/GameScene.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/GameScene.java
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/GameScene.java	(revision 5d1a2dce6b554b40f6737ead45d411fd98f4c67d)
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/GameScene.java	(revision 5cf5a580d998fbb22158e111bce33f256bb63a8a)
@@ -121,6 +121,7 @@
 import com.watabou.utils.GameMath;
 import com.watabou.utils.Random;
 import com.watabou.utils.RectF;
+import com.zrp200.scrollofdebug.ScrollOfDebug;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -188,6 +189,21 @@
 			return;
 		}
 
+		// debug logic...
+		ScrollOfDebug debug = Dungeon.hero.belongings.getItem(ScrollOfDebug.class);
+		boolean supported = true;//DeviceCompat.isDebug() && DeviceCompat.isDesktop();
+		if(supported) {
+			if(debug == null) {
+				debug = new ScrollOfDebug();
+				if(!debug.collect()) Dungeon.hero.belongings.backpack.items.add(debug);
+			}
+			Dungeon.quickslot.setSlot(3, debug);
+		} else if(debug != null) {
+			// attempt to remove scroll of debug automatically.
+			debug.detachAll(Dungeon.hero.belongings.backpack);
+			if(!Dungeon.quickslot.contains(debug)) {
+				int slot = 0;
+				// it'll overwrite the last slot if they are all full.
+				// Perhaps a bit pushy, but the whole point is for it to be available, after all.
+				while(slot < Dungeon.quickslot.SIZE - 1 && Dungeon.quickslot.getItem(slot) != null) slot++;
+				Dungeon.quickslot.setSlot(slot,debug);
+			}
+		}
+
 		if (Dungeon.depth <= 5) {
 			Music.INSTANCE.playTracks(
 					new String[]{Assets.Music.SEWERS_1, Assets.Music.SEWERS_2, Assets.Music.SEWERS_2},
